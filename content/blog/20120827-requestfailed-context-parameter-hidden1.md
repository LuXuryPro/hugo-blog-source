title: RequestFailed: Context parameter '$HIDDEN1 ...
link: http://jaffamonkey.com/7463/requestfailed-context-parameter-hidden1
author: jaffamonkey
description: 
post_id: 7463
created: 2012/08/27 16:46:29
created_gmt: 2012/08/27 16:46:29
comment_status: open
post_name: requestfailed-context-parameter-hidden1
status: publish
post_type: post

# RequestFailed: Context parameter '$HIDDEN1 ...

Failure of webtests on first playback are common, as having dynamic session session variables is common. And the automatic extraction function does not seem to do very well in this area. But as with any progamming (and this is a kind of programming), there are always minor issues to iron out when designing automated tests. A failing web test can mean that the request which fails is not always the cause of the problem. There is likely a previous request which is not behaving the same way it did during recording. It is also likely that there are some dynamic variables, such as a session id, that are hard coded in your requests and you need to modify your requests to not hard code these values. By dynamic, I mean the values are different for each iteration of the web test. There are really 2 common errors you will see and they have a similar root cause. 1\. When the automatic hidden field binding fails. When this happens you will see something like: “RequestFailed: Context parameter '$HIDDEN1.__VIEWSTATE' not found in test context”. This error message is indicating that the web test tried to extract a hidden field called VIEWSTATE from the previous response but was not able to extract it. The current request tried to use the value, but since it was not there, you received this error. So why is the previous request not flagged as an error? The reason is that the previous request was probably redirected to an error page but still returned an http status of 200 OK. So although it did not go to the same page as it did when recording, it was marked as success because of the 200 OK. The built in Extract Hidden Fields rule does not know which fields it is extracting. 2\. The second error is a current request fails because it is using a hard coded dynamic variable. In this case the request that failed really is the problem. These 2 problems have the same root cause because the first error also happens when a request is submitted with a hardcoded dynamic variable, but instead of returning an error you are just redirected to an error page. There are a few other things when debugging web tests. The first is to visually compare the playback results with what happens during recording. This can help figure out if we are on the same page after executing a request. This can be really helpful for the first type of error I described above. When you compare what you received in playback with what your browser has during recording, it will be obvious that the requests ended up on different pages. This will indicated that a request has dynamic values which need to be correlated. To do this, create a new web test and submit the first request and compare the results with what playback has. Keep moving on till you spot a problem. Keep in mind that the playback browser does not execute JavaScript. So if your page executes JavaScript while rendering, you may have slightly different results. Use VS plugin Fiddler, www.fiddlertool.com. This is a proxy recorder and will capture requests, responses, and headers during recording. You can use this to compare with what the VS web test engine is submitting to see if they match.
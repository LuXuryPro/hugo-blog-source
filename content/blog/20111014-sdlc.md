title: Less haste, more speed
link: http://jaffamonkey.com/9065/sdlc
author: jaffamonkey
description: 
post_id: 9065
created: 2011/10/14 13:44:57
created_gmt: 2011/10/14 13:44:57
comment_status: open
post_name: sdlc
status: publish
post_type: post

# Less haste, more speed

> You never change things by fighting the existing reality. To change something, build a new model that makes the existing model obsolete. \-- Richard Buckminster Fuller

With the news that one of the founding fathers of modern software development died (Dennis Ritchie - inventor of C and co-creator of UNIX), it made me think how this is the first time I feel a sense of history for modern computing. And how software development methodology has evolved, as people's understanding of the impacts of process. In the earlier days, clients just accepted products without question - as computing was considered in realms of IT people, and it was assumed that non-IT just wouldnt understand the perceived intricacies of delivery software. Waterfall was a default throughout the 1970's and 1980's, and unless a client worked out everything they wanted from the analysis stage, they would not be able to change their minds (only in special circumstances and at great additional cost). Waterfall methodology did not suit the increasing complexity of software development, and the dependncy on each phase completing before the next one started. There was no allowance for requirements change once analysis phase was complete, that was the key weakness. Waterfall is the oldest methodology and as such critising seems a ltitle akin to kicking an old man. The top-down approach did make sense in earlier days. Software engineering has been, and is continuing toi be, and ongoing learning curve. So it does make sense methodologies should account for this. As should project management. What there isnt an excuse for is taking easy path of simply slating the older ways of doing things, in order to make way for newer ways. The way to usurp is not attack, but develop another alternative that render the old way obselete, The most successful of the Agile-related methodologies for management is Scrum (though scrum predates Agile by 9 years). Widely adopted, it was primarily aimed at smaller projects with teams 8-12. A lot of modern projects fit into this bracket. What has changed significantly since Agile Manifesto was first devised, is the concept that methodology will solve problems by themselves. This may be true to some degree with software development, but management is a different matter entirely. A lot rest on the skills of the management layer, with methodologies, the assumption being you have the right person in right role. A methodology cannot accommodate team weaknesses, lack of engagement from stakeholders. If you have a poor Product Owner or Scrummaster, just observing the principles of daily meetings and Sprint planning will not magically make your project go well. There is not magic. As an example of how to solve these naturally occurring issues (after all every company, every team, is different), I will use [Kanban](http://leansoftwareengineering.com/2007/08/29/kanban-systems-for-software-development/). Kanban was devised by people from a company to deal with a problem of fully carrying through design requirements through to end-product. This was originated in manufacturing, but can easily be applied to software development. It takes an existing concept from manufacturing origins, and makes the Sprint itself more flexible. Sprint planning is not omitted, it is acknowledgement that events during a Sprint can nesessitate a change in plan. It is, if oyu like, a software development andidote to Scrum rigidity. Its not about breaking the rules, it bending them. And that is what you are supposed to do. Apply Scrum with kanban and you have a very flexible methodology - couple that with continuous integration, and you will have a cohesive process. Continuous integration is a software development practice where members of a team integrate their work frequently, usually each person integrates at least daily - leading to multiple integrations per day). Each integration is verified by an automated build (including test) to detect integration errors as quickly as possible. Many teams find that this approach leads to significantly reduced integration problems and allows a team to develop cohesive software more rapidly. This is a fundamental Agile process. The above combination is not intended to be a final solution, it is one of many potential combination and methodology customisations. Its possible that kanban is not relevant to your project, either because the stakeholder finds the concept, or there are immovable deadlines (for whatever reason). Too many Agile approaches don't allow for the very real possibility of inflexible timescales. Applying Scrum rigidly the this scenario will keep project on track - just make sure you have the right team to do it!
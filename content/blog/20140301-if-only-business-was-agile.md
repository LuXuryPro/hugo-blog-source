title: If only business was Agile ...
link: http://jaffamonkey.com/10816/if-only-business-was-agile
author: jaffamonkey
description: 
post_id: 10816
created: 2014/03/01 00:20:16
created_gmt: 2014/03/01 00:20:16
comment_status: open
post_name: if-only-business-was-agile
status: publish
post_type: post

# If only business was Agile ...

You can write BDD features how you want, but always observe Gherkin-language approach.  Most BDD tools support this language, but this by means means constricts you.  You take the base, and build on it.  And specifying requirements this way enables taking a common approach easier to maintain.  What your product owners and stakeholders need to know is why they are doing them in this way.  With Agile, people were used to defining nice easy 3 lines user stories - little interest in the collections of tasks that the team work out in planning, in order to acheive what they believe is the intention.Breaking a user story into features, and broken down into scenarios provide even more direction for development, and just as importantly, highlights risks and potential blockers.  Which why BDD is great for specification - varying degrees and granularity, depending on need.  And flexibility in accommodating change.  Smaller chunks, easier and less risky integration.  The more granular you go with your BDD scenarios, the more specific you are providing details about the user experience and design.  Sometimes it makes sense to specify a complete set of steps in one, if validation specifics have been covered earlier.  for example. 

  1. Given I go to homepage
  2. And I log in as "xyz" with password "zyx"
  3. Then dashboard for "xyz" displayed
  4. And tasks assigned to "xyz" listed alphabetically
Over time, this could be expressed as simply:- 
  1. Given I am logged in as "xyz"
The code for the four steps still exists in step form, but can be combined easily into a common user path.  Each line of a scenario is connected to it's own code.  If a client decides to change a scenario, then test will fail, until change achieved.  BDD is it's own audit tool and continuous.  There is your first line of code, DSL style.  By building scenarios in this fashion, you can build a reusable language that is easy for others to grasp.  If you have seen as many requirements as I have, then you will know there are many common things people expect from their web app - registration, form filling, search, content management. Deceptively easy concept to sell and to execute - at least to start with.  Start with UI-driven test approach, then watch a maintenance nightmare evolve!  This doesn't mean UI tests are wrong, but be prepared Now here's the next great thing - you can start to mix and match your scenario lines to make new ones - think of it as another approach to exploratory testing.  Sure, you know the know the steps work in the order they are specified in, but then follow paths not considered - it's a good way to find issues before a user does, and highlights potential security flaws.  A simple example is attempting to view a page when not logged in, or attempting view a page that your your logged-in user does not have access to. Who writes the tests?  Well, that's where that lazy new role of "developer in test" came about.  A poor description, but what is actually needed is a tester to build a automated test framework.  The developers can do this, and indeed in companies on tighter budgets, this is common.  This is why tools such as Jasmine use a bridge between natural language and code - closer to the way a developer thinks.  The way a developer thinks of behaviour is different from the client. True, code behaviour is related to user behaviour, but not directly. Best approach is by consensus, i.e. all project members contributing and  maintaining the features, but in reality, this can lead to a load of management and administration. With a good team, this isn't actually that hard.  The complexity comes from that pesky thing called human nature. When you have a tightly run development process, anyone outside the circle can quickly feel "blocked".  When in fact it is more simply, that they haven't "joined in".  What makes this stranger is that most modern approaches factor in the client at every stage, and what does the person with most to gain doing?  Turning up once a week, sometimes less frequently, and meetings become a paranoia-maintenance exercise.  I turn my back, therefore someone is doing something behind it.  Out of sight, out of mind. While the cats away ... etc. Anyway, so now you have this great approach, releasing and testing frequently.  CI (including BDD tests) can generate some good statistics and reports.  But what the drop-in visitor really wants to know is how far have we got, and how far we have to go. Transparency works when you are part of the heart of development, but can cause confusion and alarm in others.  No-one wants to know about process of risk assessment, mitigation, unforeseen integration complications.  This is normal development, but to list it like that, it sounds like an unappealing reality-hit too far for the average client. It's an unanswered question, as it is one business has to adapt to.
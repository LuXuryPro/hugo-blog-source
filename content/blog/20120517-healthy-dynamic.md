title: Healthy Dynamic
link: http://jaffamonkey.com/7138/healthy-dynamic
author: jaffamonkey
description: 
post_id: 7138
created: 2012/05/17 00:26:03
created_gmt: 2012/05/17 00:26:03
comment_status: open
post_name: healthy-dynamic
status: publish
post_type: post

# Healthy Dynamic

[Rapid Software Testing](http://www.satisfice.com/info_rst.shtml) does have me intrigued, as it is neither flowery or condescending. I am usually suspicious of test approaches that claim to fit into any project, using any methodology. The differences in testing are not that radical from methodology to methodology, but a trend grew of people with little understanding, trying to rewrite what testing is, to fit in a preconceived place. The problem is that when people rewrite according to preference, rather than project benefit. And when developers take control, you can be sure testing's place will not be as high profile as it should be! Qualifications, such as ISEB, didn't improve the general quality of testers in the marketplace, and the BCS Agile testing cert will do little to help on that front. Amongst the objectives lies this little gem.... 

> Differentiate between the testing role in agile projects compared with the role of testers in non-agile projects

Oh really? A someone who has traversed many projects, using Agile, Scrum, RUP, Waterfall, RAD ... I can safely say that they should be very little difference at all. Would project management or development be happy to slot their process into a testing methodology? No of course not, that's ridiculous. What I am primarily interested in when test planning is the entry/exit criteria for testing, and sign-off process. Even those are not determined by methodology, but by an agreed set of rules. Who needs methodology when good practice is much more logical and easier to teach and understand? Explaining how to do things is easier than trying to get everyone into a methodology mindset. 

> A stereotypical description of an application testerâ€™s role is usually about being given specifications, reporting bugs, verifying and closing bugs. This stereotypical tester will have a part to play in a testing organization, but will always be considered an outsider to the project and will not have much impact on the project lifecycle. [The Shift, From Stereotypical to Effective Tester](http://www.softwaretestpro.com/Item/5329/The-Shift-From-Stereotypical-to-Effective-Tester/Process-Best-Practices)

To approach learning to be a tester isn't helped by having a label applied to you from the outset. There are enough problems with stereotyping in testing. Testing is better methodology agnostic, rather than trying to shoehorn project management and development process into QA. An awareness and understanding of project management and development processes are very beneficial, but key point to understand when learning how to be a tester, is the special relationship between development and testing. A developer is always convinced that their code is bug-free and that the tester is not going to find a bug. Whereas the testers mission (whatever they say) is to find bugs, because there are always errors on some functional path, however minor. It's a healthy game, and it is paramount that development and testing has a good bond. It leads to cross-functional working, and a more supportive environment. This is the healthy competitive developer/tester dynamic, and remained largely unchanged until QA lost ground on many projects, and testers became a tolerated accessory rather than a project essential. Applying sound processes to development such as continuous integration, and stakeholders more pro-actively engaged in UAT, meant many saw this as excuse to budget cut. For some, it was essential, but for most it was a false economy. We in QA are partly at fault, as for the most part, demotion of the tester role was around misunderstandings of the added value it brings, when judged from Agile perspective. So we need to sell ourselves harder. And modern testers must become more skilled at programming. For a tester, programming skills can be approached in a language-agnostic fashion, as tools usually support many languages. You don't have to use the language of the application under test, to test it. Although each programming language has it's variations on syntax, there is a lot a commonality between them all. So much testing can now be done at code level, and there are many ways to help achieve this, from headless-browsers to DSL-driven development and security tools. Testing has a freer rein to use more than one tool, more than one approach. That's the real way to work out your testing process - by efficient experimentation, and consideration of more than one solution. Testers can do this, which is taking many different tools to achieve the goals. Development world is a little behind on that one. The many obsessive .NET and Java oriented companies demonstrate this fact, as in those environments there is strong resistance to anything out of the norm in development. One programming language is generally used; with an odd belief that it's better that you have many people knowing one thing well. Other languages may be used, but only when forced, rather than a reviewed choice. In fact, that is building a technology prison, and you can end up missing the most basic skills. Both [Rapid Software Testing](http://www.satisfice.com/info_rst.shtml) and [Context-driven Testing provide a good basis, for people getting into testing. They both encourage an adaptable and multi-displined approach to testing, that elevates the role of tester to place of importance it should be.
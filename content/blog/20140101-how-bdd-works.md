title: How BDD really works ...
link: http://jaffamonkey.com/10804/how-bdd-works
author: jaffamonkey
description: 
post_id: 10804
created: 2014/01/01 20:21:14
created_gmt: 2014/01/01 20:21:14
comment_status: open
post_name: how-bdd-works
status: publish
post_type: post

# How BDD really works ...

![bdd-cycle-around-tdd-cycles1](/wp-content/uploads/2014/01/bdd-cycle-around-tdd-cycles1.png) This is down to tester and developer perceptions of what "Behaviour" means - and perceptions that are BOTH valid.  The tester looks at feature files (i.e. user story plus scenario(s)), and sees them as the acceptance tests. Behind the scenario statement lines is where the tester will add code to automate the test.  The back-end developer will look at the feature files, and immediately think in terms of development tasks and dependencies needed to perform the functionality (i.e. pure functional behaviour).  The front-end developer will take UX and design cues from the feature files directly.  This is generally how a BDD project will work. In real life. The assumption of pure BDD is that developers work from feature files downwards, i.e. construct tests to facilitate user acceptance level and unit test level.  I saw a developers, a very good one, struggle an entire day with a scenario.  Designing scenarios can be simple, but if they include many calculations and conditions, it has to be structured impeccably.  No mean feat, which is why the tester can play an important role to play to keep BDD relevant, as to a tester, this is simply about analysis and asking questions of those who can help.  After all, BDD is supposed to be a collaborative process.  But it is flexible enough to slip into QA area, which it will be treated as any other acceptance test framework. Adopting Page Objects approach to building your automated tests (essentially, you are building a [DSL](http://en.wikipedia.org/wiki/Domain-specific_language)) is a pragmatic one, as it separates out design from functionality.  There are tests that do not require a UI, by simply interrogating API return data, and Page Objects lends itself well to describing "Behaviour" on several levels, in code form. This means both front-end and back-end can have a clear view of what is required of them to ensure a scenario passes. "Page Objects can be thought of as facing in two directions simultaneously. Facing towards the developer of a test, they represent the **services** offered by a particular page. Facing away from the developer, they should be the only thing that has a deep knowledge of the structure of the HTML of a page (or part of a page) It's simplest to think of the methods on a Page Object as offering the "services" that a page offers rather than exposing the details and mechanics of the page." _http://code.google.com/p/selenium/wiki/PageObjects_ I still thiink there is not much distance between BDD and Acceptance Testing Framework approach- they both aim to provide an easy means for project members to create and maintain requirements, in form that is tied into automated tests. Fitnesse and Selenium have long provided a platform to to this, it was with the advent of specification languages such as [Gherkin](http://uk.yhs4.search.yahoo.com/r/_ylt=A7x9Uk2Kd8RSSAYAoxN3Bwx.;_ylu=X3oDMTByNGxmazk4BHNlYwNzcgRwb3MDMQRjb2xvA2lyZAR2dGlkAw--/SIG=125p70th4/EXP=1388636170/**https%3a//github.com/cucumber/cucumber/wiki/Gherkin), that finally built the bridge between the developer and the client, in terms of common goals. Whether developers join the BDD party fully or not, it's a very effective approach from a tester perspective. As with other acceptance test frameworks, it shares the tool mindset - geared for usability and view of progress in manner any person can understand. I used Fitnesse for several years, which was geared to a similar DSL approach to acceptance criteria, albeit more technically-oriented that modern Gherkin-based tools. QA can take the opportunity to be a bridge, positioned as we are between the developer and client.  If you find yourself working on BDD project, you will most likely find developers are not following a feature file acceptance tests approach, and most likely have fallen back into the safety net of unit tests.  How effective unit tests are these days is questionable!
title: Organised Chaos
link: http://jaffamonkey.com/11212/2014-bdd-github-planet
author: jaffamonkey
description: 
post_id: 11212
created: 2014/12/12 21:17:08
created_gmt: 2014/12/12 21:17:08
comment_status: closed
post_name: 2014-bdd-github-planet
status: publish
post_type: post

# Organised Chaos

BDD could be seen as stepping stone to client's writing acceptance tests. The more I worked with BDD projects, the more I have noticed how small the language is, that people use to define requirements. Having Gherkin really helps add structure, though it is just stepping stone to developing truly relevant domain-specific language, i.e. reusable. I am not suggesting for a moment this is the ONLY way. But it is one I have gravitated to by far the most passionately. I am guessing it's because I see a true rapid advancement in a software development approach, with BDD. it pushes testing boundaries very quickly, and challenging in maintaining -treating it like any other application code is the way to approach it. One of the more mortifying things was when (after a year), I did a brutal cleanup, and realised once I removed now redundant tests, and combined/optimised other, it was a lot smaller. But as one developer said to me (with a smile) when I told him: "welcome to world of programming". Then I felt better, as I realised I hadn't followed a half-bad path, and ended up with a reasonable set of Gherkin statements for reusing. In fact, over time, people had got used to the certain way to phrase requirements, or changes. One nice side-effect from working on BDD-driven open source project, was introducing to the winderful world of gihub, and the myriad of code. A library that ended up essential, the the dirve for rapid quality-driven development. As I have said many times, BDD is not for the faint-hearted, and a leap of faith to maintain it. Unfortunately, it can be dropped with minimal immediate impact, but within months, the change will be noticed, and the BDD process that was, will become more disparate.
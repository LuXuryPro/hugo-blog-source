title: Agile test automation
link: http://jaffamonkey.com/5153/agile-test-automation
author: jaffamonkey
description: 
post_id: 5153
created: 2011/12/05 17:30:05
created_gmt: 2011/12/05 17:30:05
comment_status: open
post_name: agile-test-automation
status: publish
post_type: post

# Agile test automation

How does automated testing fit into Agile? It hasn't changed that much, but a sensible approach (assuming development process is also sensible), is to do a combined UI and code level test, so you minimise the high-maintenance part (the UI tests). UI tests are always appealing, as easy to generate (with fine tuning, of course) but ultimately they are harder to maintain ongoing. The first flurry of automation can lead to a muddle of part-baked scripts, with no-one maintaining them and little relevance to requirements.  [caption id="attachment_5185" align="alignright" width="300" caption="From Leonard's Comic - Unit Testing"]![](/wp-content/uploads/2011/12/why_automation.png)[/caption] There is a general hysteria around automated testing - people want it, then stress because they don't understand the value. To understand the value of test automation, you understand the aim - and the aim is to design cohesive process of testing, that can be run against current validated build, at any time, by anyone (not just end of Sprint). This is where good tools help. Though you can take your prompt from user stories and scenarios, if development is following ATDD with tools such as Specflow, Fitnesse or Cucumber, you can easily identify areas to do UI tests.   UI tests typically test functionality, and if you are using Fitnesse you can centrally run tests both at code level, and through UI, by making calls to Selenium scripts. So that how to divide up the testing types, so about test data ... The ideal is to have a reset point to return to after your tests. The UI tests can help with this, effectively doing a reverse loop. But maybe one of the code tests will also do the job. Keeping this constant cross-referencing keeps testers in touch with the application at code and UI level. Automated web testing can be divided into three categories, and example below is using Fitnesse/Selenium combination: 

> **Web Form DSL (Example  : Fitnesse)** **Browser API (Example : Fitnesse-script/Selenium-script bridge)** **Web Driver API (Example : Selenium web-driver)**

While most will agree unit tests are essential and part of fundamental good software practice, there are scarily absent. ATDD-type methodologies like BDD, highlight this quickly are there is transparency in process that won't be hidden by source control, or developer hyberbole. One of the main reason for the popular combination of Fitnesse and Selenium is you can drive unit tests and UI-driven tests from the same place, and are inorexably tied to the acceptance criteria. Fitnesse manages the user stories/ scenarios then it has inbuilt test harness, that can support numerous development environments. Fitness scripting language also enables calls to selenium scripts, to drive UI tests. There are mods that tie the two products even closer together, allowing user to define scenarios in form that means you do not have to create separate selenium scripts. Unit tests and UI tests should complement each other. Certain checks are more given to front-end activty, such as downloading an exported file and verifying contents. This can be done at code level, but in this scenario, performance and export system are also relevant test criteria. A general guide is that UI tests are for functional checks, unit tests are for back-end checks. In order to minimise ongoing maintenance, the testing should be wieghted towards unit-level tests.  It's probably a good time to put up a diagram, which best illustrates where automated testing fits in, across project lifecycle. It's a simple diagram - and that's how it should be - the variables (as ever) are human beings. ![](/wp-content/uploads/2011/12/atdd.png) Now here is where some get confused - are testers doing the unit tests? Yes and no - the testers should design white box tests using DSL approach, which requires code understanding, but not in-depth programming knowledge. Another description is psuedo code - a way to write in programming language agnostic way, that will mean something to a developer, and provide a clearer path from user story/scenario, through to code. Below is an example of the DSL format, relating to C# style. There are many ways to design DSL - just ensure to follow the same style. 

> **begin story "AUserStory":** ** begin setup** ** @Person to have a ~Spouse(@Person)** ** ~IsActive(true)** ** ~Age(0)** ** ~IsDead(false)** ** and several ~Children(@Person)** ** and a ~Location(@Location)** ** I want a @Person to be able to #Kill another @Person** ** I want a @Person to be able to #Marry another @Person** ** I want to be able to #Find all @Person** ** @Location to have a ~Latitude(0.0)** ** and a ~Longitude(0.0)** ** end setup** [Domain Specific Language For Business Objects](http://stackoverflow.com/questions/573580/domain-specific-language-for-business-objects)

A common pitfall is that testers work ends up spilling into developer work. From the DSL a tester provides, the coder will complete the TDD test in code, which is final step before writing functional code. It is easy for tester to slip into bad habit of maintaining the actual TDD tests, which is still in development remit. A good Scrummaster won't let this happen, but that's a weakness right there - assumption of a good Scrummaster. If you, as a tester, feel you are encroaching too far outside your remit, then voice it - no-one is going to disagree on the point once voiced. It's an illogical use of a tester. Tools such as specflow, cucumber and Fitnesse DSL plugin such as Xebia and Fitnium can help avoid this pitfall. These tools can generate the DSL based on user story/scenario input. This is definitely the way forward, and as programming progresses, no doubt intelligent code-generation at lower level will be possible. It's not just testers who need to keep up ;)
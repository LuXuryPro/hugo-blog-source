title: Natural language as code
link: http://jaffamonkey.com/11500/natural-language-as-code
author: jaffamonkey
description: 
post_id: 11500
created: 2015/06/04 02:51:41
created_gmt: 2015/06/04 02:51:41
comment_status: closed
post_name: natural-language-as-code
status: publish
post_type: post

# Natural language as code

> A domain-specific language (DSL) is a computer language specialised to a particular application domain. This is in contrast to a general-purpose language (GPL), which is broadly applicable across domains, and lacks specialised features for a particular domain.

`As mall administrator, I want to create an online shop which sells domestic services, with customer relations management tools.` It's an Agile Epic on the face of it, but I am following BDD process, which assumes single Feature, until scenarios prove otherwise. The style has a wider scope than User Story format, though such a myriad of explanations exist out there for a Feature, and from notable people.  Though I may get shot down in flames, I see Features as a close cousin to Use Cases (already I can see shaking heads). What the BDD feature breakdown process does well, is highlight quickly where more specification needed. Unlike traditional Agile style, where User stories are broken down into various team tasks, with BDD approach, you break down Feature into scenarios, still using Gherkin (an accepted BDD specification language format (DSL*)).  Only developers are interested in developer tasks. The overall progress view is better served by Feature coverage. This Epic could be a valid User Story, Feature, Scenario, or even a single gherkin line statement ... if you wanted it to be.  Gherkin is not written in stone, and sometimes I feel the out-of-the-box Gherkin you generally get with the tools creates that false impression.  I have seen so many negatives reviews based on that. Anyway, returning the the Feature, and creating a shop with a category. This could be a simple one liner, but of course will maps to multiple lines of test code behind it, perhaps using existing functions, in turn mapping to Gherkin steps of their own. The Gherkin is a simplified view of the code behind, and as it's intrinsically linked, it is important to treat the Gherkin as code.  This is the more Gherkin-friendly view of the User Story: ` # Feature needed for authentication Given I am logged in as a mall administrator # Feature needed for shop creation with category When I create a "domestic services" online shop "shop A" #Feature needed for CRM access Then the shop has CRM access ` In BDD terms this is where the developer would code to make the acceptance tests (scenarios) from the Feature, pass. But as I want to demonstrate creating Gherkin, I will assume this services exist at least to state that the Feature will successfully execute. So now we have a first useful reusable scenario. If services haven't been completed yet, then it's one to run further into the project lifecycle. At end of this executable Gherkin scenario, a new shop with name "shop A" should be created, in a shop category of "Domestic services", and unique shop access given to CRM component to managers orders and customer contact ( a few assumptions at the end there, but this is just a demo). The two lines with clear hidden functional complexity, will involve a combination of actions and dependencies.  It's is in the coding of these, we also need to keep reusability in focus, and not code what has already been coded elsewhere, or could be refactored to better reusability.  So first is the one-liner log in, which can quickly be written as: `Feature: As user, I want to be able to log in as a role assigned to me, to carry out relevant actions Scenario: Log in as mall administrator Given user "malladmin" with role "Mall admionistrator" exists And I am on "Login" page When I fill in "malladmin" for "username" And I fill in "Password1" for "password" And I press "Login" Then I should see the "Mall administrator" user homepage ` Creating a shop obviously entails more functionality, and will be comprised of one or more features.  You will notice in example below, the original Gherkin step to create shop, is a Scenario in this Feature.   So to execute that original Gherkin line, becomes a matter of executing the scenario from this other Feature. This is defined in underlying code, rather than in the Gherkin itself. `Feature: As a mall administrator, I want to be able create a online shop in a certain category, using the preset values for that category Scenario: Create domestic services shop using default values for category Given I am on the "Shop Management" page And I am on the "Create Shop" page When I select "Domestic services" from "Shop category" Then form should contain: | Category Preset Field 1 | Category Preset Field 1 Value | | Category Preset Field 2 | Category Preset Field 1 Value | | Category Preset Field 3 | Category Preset Field 1 Value | | Category Preset Field 4 | Category Preset Field 1 Value | # Form filling is by far the biggest volume of Gherkin line statements, # so where this can be optimised or "prettified" When I fill form with values: | shop name | shop A | | field name 2 | field value | | field name 3 | field value | | field name 4 | field value | And I press "Create shop" Then I should see "New shop has been created" ` Now we have the third line, and for this I am going to assume that the service exists, and automatically generates a new CRM space for the new shop. `Feature: As a mall administrator, when I create a new online shop, a new instance of a CRM should automatically be generated. Scenario: Assert that newly created shop creates new instance of CRM # This could be created via API, or by executing the scenario above Given a new shop "shop A" exists And I am on the CRM homepage # For purpose of testing, created shops will be assigned predictable password and id based on shop name. When I log in to shop "shop A" CRM area Then I should see "Welcome, shop A" ` Reuse should always be at the forefront of your mind in this kind of exercise, when creating test code and observing poge objects approach is a good path to follow (but not the only). Below are the contexts generated from the exercise (remember that Gherkin steps can have either Given/Then/When/And, these is purely for readability):- 

  * I am logged in as a mall administrator
  * I create a "shop category" online shop "shop name"
  * the shop has CRM access
  * user "user name" with role "role name" exists
  * I am on "page name" page
  * I should see the "user name" user homepage
  * The form should contain:
  * I fill the form with values:
  * a new shop "shop name" exists
  * I am on the CRM homepage
  * I log in to shop "shop name" CRM area
  * I fill in "form field value" for "form field name"
  * I press "button name"
There a few here that mask multiple steps - it's just part of an ongoing process, taking high level requirements, and making them more granular. The important part to realise is you are building a programming language, and every language has structure and rules (natural language included).   ![meme-functions](/wp-content/uploads/2015/06/meme-functions.jpg)
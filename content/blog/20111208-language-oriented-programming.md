title:  if … then … else
link: http://jaffamonkey.com/5210/language-oriented-programming
author: jaffamonkey
description: 
post_id: 5210
created: 2011/12/08 21:22:42
created_gmt: 2011/12/08 21:22:42
comment_status: open
post_name: language-oriented-programming
status: publish
post_type: post

#  if … then … else

I always find it a little depressing when I start reading articles on the next level of programming languages, only for it to disappoint by simply plugging future of Ruby-off-rails or some catastrophic clunk like Adobe Flex. I think the future of programming has got to be speedier transition from requirements to functioning code. Domain-specific modelling using DSL(s), is in the right direction. If you study the progression of programming languages, they are becoming more readable in linguistic way.  I should point out that my experience is largely on web applications of various size and complexity, so most of my thinking is based on this. There has to be a time, when we can use common language to express requirements and auto-generate code based on those. Sounds a little strange for older generations in IT, but it has been evolving for a long time. SQL and HTML are both earlier DSL's, readable as they are in their natural form as well as explicit instructions. Before you think this is impossible, programming languages are very similar, in that they are executing instructions and manipulating data. You can choose to build a web application with any number of languages, but they can all fulfil the same goal. Why? Well how many different ways can you express **if ... then ... else**? How many ways can you define a variable? Some languages are more readable than others. Languages such as Prolog started the way for more language-driven programming, but the big downside is its limitations. But is that really such a big issue, when it is good for specific purposes - something else could address other complexities. I am sure earlier programmers in Assembly would have laughed at the concepts of object-oriented programming or TDD. When you grow up in a particular era, when things REALLY change, it is difficult to get to grasps with new concepts. Especially as they seem to challenge everything we previously thought. As I dug deeper into DSL's (specifically around usage in Fitnesse ATDD tool, to drive Selenium tests), I came to what was in hindsight, a natural progression of the research. In fact the surge of use of ATDD is indication of addressing the problem of fulfilling business requirements, and that most problems are occurring in the journey from requirement to code, and development process. Exactly what DSM (Domain-Specific Modelling) is attempting to address. DSM raises system development beyond programming, by specifying the solution directly using domain concepts. In many cases, final products can be generated automatically from these high-level specifications. This automation is possible because both the language and generators need fit the requirements of only one company and domain. That means there is no "one solution" - this can happen, but companies to do develop a strategy to make it happen. DSM is a broad subject, but in a nutshell, it is about the creation of executable source code directly from the DSM models (which is facilitated by DSL's). Putting it in a simpler Agile-style way – ideally the client could create user stories and scenarios, and in DSM world, that alone would be sufficient to generate the code. We are not even close to that level of efficiency, and this is down to the way projects are still approached in most businesses. There is a lot more to change than just programming - tools and newer software development methodologies (particularly Lean) are evolving fast, but the best we have now is part-implementations of this principles, and API's between tools to achieve this ideal path. Major dangers are the reliance of pivotal tools/maintenance to ensure the process flows smoothly. And the quality of work done at the requirements specification level. At this moment in time, it is possible to cobble a set of tools and API's together to take a step into this world. Products like Specflow go some way to achieve this, but very limited in terms of maintenance. Re-factoring projects, or projects where requirements are constantly changing, could quickly lead to development admin nightmare. The random successes of the current ATDD trend will evolve into something with a lot more stability. DSL is becoming relevant with evolution of Domain-specific modelling (DSM). Modern programming languages and tools make the job of actual programming easier and more readable. So the next step is for people to do requirements in form that is virtually code already. You can do it now, It a good point to highlight, yet again, that processes are no magic, they need buy-in, good implementation and maintenance. Good Agile software development practice is also imperative.
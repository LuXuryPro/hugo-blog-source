title: Smarter architecture with DSL
link: http://jaffamonkey.com/6879/smarter-architecture-with-dsl
author: jaffamonkey
description: 
post_id: 6879
created: 2012/04/09 16:07:30
created_gmt: 2012/04/09 16:07:30
comment_status: open
post_name: smarter-architecture-with-dsl
status: publish
post_type: post

# Smarter architecture with DSL

The soup is SOA with DSL Maybe it's time to write new language. As a programmer working at a company, you must find yourself writing same chunks of code time and time again. Sure, you build up your own libraries to reuse. And if you are going to do that, why not create a class/function to use that call that code. And you don't need to just use one programming language. This mentality is not so prevalent in web development. A lightweight, but relevant example is virtually every website will have HTML and Javascript - Javascript is sometimes more appropriate for a given website feature, or simply only possible with it. What we are doing by accident or by design, is writing our own languages – the fact they are based on 1 or more other programming languages is irrelevant. It feels like its time to re-address how we look at programming languages, as selling up to particular technologies is a dangerous game to play, in the long-term. 

> It is always a good idea to write a DSL. There is no better way of becoming a domain expert than implementing a custom language for that specific domain. http://blog.nofail.de/2010/02/writing-your-own-dsl-with-ruby/ 

Although there have been many benefits of Domain-Specific Languages (DSLs) reported from both academia and industry, implementation of DSLs continue to face challenges with respect to frequent evolution of both syntax and semantics. Some languages are more geared for DLS than others (Ruby is a good example). Techniques for implementing DSLs also lack interoperable capabilities among base languages and limited tool support. Such challenges result in increasing DSL development cost and constrain DSL adoption opportunities. It's early days - but there is no reason that companies can't start developing a strategy for DSL projects. No room for individual project politics here - you need cohesion. Have I been harsh on Ruby on Rails?  Perhaps - as the underlying ethos of RoR does make a lot of sense.  The phrase that always makes me wince is "I can do more with less code".  That is not necessarily a bad thing - unfortunately the phrase also has an association with lazy development (developers). Ongoing programming library development, new helper objects, are all part of the programming evolution. But it can be done badly. You can't have developers who only understand their programming environment from component perspective, and issue diagnosis will involve lower level understanding. Software that used to be an entire system, has become a component, and that seems perfectly logical. A CMS (Content Management System) is one of them - a common set of features that becomes a feature itself. If your company developed software on SOA principles, you would be surprised by how much work can be save in the long-term. There are many commonly used features in application development, and none more so than on web applications. It is far easier to present requirements in form of components, and the more advanced and flexible these components are, the easier it would be to implement them in code closely to requirements. Clients are generally asked to think too granular these days - I mean, does the client really need to have an opinion on password length? There are a lot of standards on the web, and it is advisable to follow those standards. To effectively share and reuse of your DSL, it is necessary to provide a consistent programming environment with clear set of limitations and rules. This is called the Application Programming Interface (API).  An API is an essential part of Service-Oriented architecture, as well as any other software architecture, because it can be used as independent logical layer. Below is very simple representation of SOA, which has been largely misunderstood (or more correctly, underestimated). ![](http://blog.jaffamonkey.com/files/2012/02/SOA1.jpg) The key to SOA is the business logic layer (i.e. potential shared services). And this is where DSL comes in, or should do. DSL transforms programming logic, into architectural logic. Computers are only going to be as dumb as we make them.
title: Kanban Polyglot
link: http://jaffamonkey.com/6511/kanban-polyglot
author: jaffamonkey
description: 
post_id: 6511
created: 2012/05/28 14:26:12
created_gmt: 2012/05/28 14:26:12
comment_status: open
post_name: kanban-polyglot
status: publish
post_type: post

# Kanban Polyglot

> .... the essence of software engineering consists of working out the specification, design, and verification of a highly precise and richly detailed set of interlocking concepts. What makes software development difficult is its essential complexity, conformity, changeability, and invisibility. "No Silver Bullets—Essence and Accident in Software Engineering" (Fred Brooks, April 1987).

[caption id="attachment_7220" align="alignright" width="214" caption="The Polyglot Man - Orange (Joan Miro - 1969)"]![The Polyglot Man - Orange \(Joan Miro - 1969\)](/wp-content/uploads/2012/05/Joan_Miro_The_Polyglot_Man-Orange.1969-214x300.jpg)[/caption] The title sounds like a character from Hitchikers Guide To The Galaxy, but the two are very relevant to each other. Kanban has been rolling around my thoughts and online rants for a while now. I am still learning - I would never be arrogant enough to assume my learning has stopped. And that I can get trapped down a rabbit hole as easily as anyone else when trying to work out the best process. The wave that carried Agile was rough, but it was also an essential learning curve. But in widespread application as purely as a user guide, rather than using it as guidelines, there were errors of judgement. The most common being that the processes devised (or more likely copied) were not being followed through. This was down to general misunderstanding of what Agile was to start with, but also the resistance to change - a risk with any change within a company, not just software development. Whilst business world nodded to Agile, liked the ethos, liked the idea of faster and better quality delivery, it singularly failed to go Agile itself. Or modernize at all. For all the advancement, I still see a gulf between business and development - in fact, even more so with Agile/Lean, because of their promotion of transparency, experimentation, embracing mistakes as learning opportunities. These aren't natural bedfellows for business. But it is too easy to waste too much space whining about that problem. Perhaps a better strategy is to implement processes to development cycle by stealth. Largely business don't actually care about the process, they care about the product. Software development has become too machine like - the idea that anyone can be a programmers is a tempting chant. It's accurate but let's face it, just actual coding (especially with all the helpful IDE's these days) is a small part of the project story. I decided to learn a new language, or as it's C++, relearn something I haven't touched for many years.  Programming languages generally evolve over time, I mean the fundamental ones like C++ which really brought object-oriented programming to the fore.  When I was choosing, I decided to go for an established and still popular language.  It's faster to run than many modern languages, and more robust and scalable.  The impatient fervour around Ruby on Rails was too early, as people essentially lactched to its flashy timesaving features, rather than being concerned with the substance. Creating a programming language is one thing, but it has to go through years of implementations and learning to discover it pros and cons (and all languages have them).  Polygot programming illustrates ideas of using using languages for different features - one language is rarely appropriate for an entire system.  Choosing a fundamental language to learn seems a better approach, as when learning a fundamental languages, other languages can be learnt a lot more quickly.  The jump from C++ to Ruby is a lot less painful than vice versa.  Rather than waste time on more narrow fluff languages, I prefer to learn one that inspired many other languages. http://polyglotprogramming.com/ http://www.jedi.be/blog/2010/02/12/what-is-this-devops-thing-anyway/